from __future__ import annotations

import base64
import hashlib
import os
from pathlib import Path
from typing import Optional, Literal

import requests
from fastapi import FastAPI, Query
from pydantic import BaseModel

# --- Config ---
DEFAULT_GATEWAY_FORWARD_URL = os.getenv("GATEWAY_FORWARD_URL", "http://127.0.0.1:8000/forward")
KEYS_DIR = Path(__file__).resolve().parent
PRIVATE_KEY_PATH = Path(os.getenv("SENDER_PRIVATE_KEY_PATH", str(KEYS_DIR / "private.pem")))
PUBLIC_KEY_PATH  = Path(os.getenv("SENDER_PUBLIC_KEY_PATH",  str(KEYS_DIR / "public.pem")))


# If you set GENERATE_KEYS=1, sender can generate keys if missing (useful for demos)
GENERATE_KEYS = os.getenv("GENERATE_KEYS", "0") == "1"

app = FastAPI(title="Sender (Hashing + Send to Gateway)")


# -------------------------
# Models
# -------------------------
class SendRequest(BaseModel):
    message: str
    # If you (Person 2) donâ€™t sign, you can paste signature_b64 generated by Person 3 here.
    # If omitted, sender will try to sign using PRIVATE_KEY_PATH.
    signature_b64: Optional[str] = None


class HashDemoRequest(BaseModel):
    message: str
    # change exactly one character to demonstrate avalanche effect
    index: int = 0
    new_char: str = "X"


# -------------------------
# Hashing helpers (Person 2)
# -------------------------
def sha256_hex(message: str) -> str:
    return hashlib.sha256(message.encode("utf-8")).hexdigest()


def mutate_one_char(s: str, index: int, new_char: str) -> str:
    if not s:
        return s
    i = max(0, min(index, len(s) - 1))
    return s[:i] + (new_char[:1] if new_char else "X") + s[i + 1 :]


# -------------------------
# Signing helpers (optional; usually Person 3)
# -------------------------
def maybe_generate_keys() -> None:
    """
    Optional: generate an ECDSA keypair if missing.
    Only runs if GENERATE_KEYS=1.
    IMPORTANT: receiver must verify using the matching PUBLIC key.
    """
    if not GENERATE_KEYS:
        return

    if PRIVATE_KEY_PATH.exists() and PUBLIC_KEY_PATH.exists():
        return

    KEYS_DIR.mkdir(parents=True, exist_ok=True)

    from cryptography.hazmat.primitives.asymmetric import ec
    from cryptography.hazmat.primitives import serialization

    private_key = ec.generate_private_key(ec.SECP256R1())

    priv_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption(),
    )
    pub_pem = private_key.public_key().public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )

    PRIVATE_KEY_PATH.write_bytes(priv_pem)
    PUBLIC_KEY_PATH.write_bytes(pub_pem)


def load_private_key():
    from cryptography.hazmat.primitives import serialization

    if not PRIVATE_KEY_PATH.exists():
        return None

    data = PRIVATE_KEY_PATH.read_bytes()
    return serialization.load_pem_private_key(data, password=None)


def sign_message_b64(message: str) -> str:
    """
    Signs message bytes using the private key at PRIVATE_KEY_PATH.
    Supports RSA or ECDSA keys depending on what PEM you provide.
    """
    priv = load_private_key()
    if priv is None:
        raise FileNotFoundError(
            f"Private key not found at {PRIVATE_KEY_PATH}. "
            f"Either provide signature_b64 from Person 3, or set GENERATE_KEYS=1 (demo only), "
            f"or place a PEM key at that path."
        )

    msg_bytes = message.encode("utf-8")

    # Detect key type and sign appropriately
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding

    if isinstance(priv, rsa.RSAPrivateKey):
        sig = priv.sign(
            msg_bytes,
            padding.PKCS1v15(),
            hashes.SHA256(),
        )
    elif isinstance(priv, ec.EllipticCurvePrivateKey):
        sig = priv.sign(
            msg_bytes,
            ec.ECDSA(hashes.SHA256()),
        )
    else:
        raise TypeError(f"Unsupported private key type: {type(priv)}")

    return base64.b64encode(sig).decode("utf-8")


# -------------------------
# API
# -------------------------
@app.on_event("startup")
def _startup():
    maybe_generate_keys()


@app.get("/")
def health():
    return {
        "status": "sender running",
        "gateway_forward_url": DEFAULT_GATEWAY_FORWARD_URL,
        "private_key_path": str(PRIVATE_KEY_PATH),
        "public_key_path": str(PUBLIC_KEY_PATH),
        "generate_keys": GENERATE_KEYS,
        "endpoints": ["/hash_demo", "/send"],
    }


@app.post("/hash_demo")
def hash_demo(req: HashDemoRequest):
    original = req.message
    modified = mutate_one_char(original, req.index, req.new_char)

    return {
        "original_message": original,
        "original_sha256_hex": sha256_hex(original),
        "modified_message": modified,
        "modified_sha256_hex": sha256_hex(modified),
        "explain": "Changing 1 character causes a completely different SHA-256 hash (avalanche effect).",
    }


@app.post("/send")
def send_to_gateway(
    req: SendRequest,
    mode: Literal["pass", "tamper"] = Query("pass"),
    gateway_forward_url: str = Query(DEFAULT_GATEWAY_FORWARD_URL),
):
    # Person 2: always compute and show hash
    hash_hex = sha256_hex(req.message)

    # Signature: either provided (from Person 3) or sign locally if key exists
    signature_b64 = req.signature_b64
    if signature_b64 is None:
        signature_b64 = sign_message_b64(req.message)

    payload = {
        "message": req.message,
        "signature_b64": signature_b64,
    }

    # Send to gateway (gateway will forward to receiver)
    r = requests.post(gateway_forward_url, params={"mode": mode}, json=payload, timeout=10)
    r.raise_for_status()

    return {
        "sender_message": req.message,
        "sender_sha256_hex": hash_hex,
        "signature_b64": signature_b64,
        "gateway_mode": mode,
        "gateway_forward_url": gateway_forward_url,
        "gateway_response": r.json(),
        "explain": "Sender hashes the message (SHA-256). Signature is sent alongside message for receiver verification.",
    }
